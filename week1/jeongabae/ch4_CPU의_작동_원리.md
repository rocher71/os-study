# 04-1 ALU와 제어장치

## **ALU** : 계산기~

- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 제어신호 받아들임.

<img width="541" alt="image" src="https://github.com/user-attachments/assets/1a634986-a79a-4f14-8a63-95886b5c047c" />


- ALU 결괏값을 메모리가 아닌 레지스터에 우선 저장(because 접근 속도)
- ALU는 연산한 결괏값과 플래그를 내보냄.
- 플래그 : 연산 결과에 대한 추가적인 정보 상태
    - 부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그
    
    <img width="453" alt="image" src="https://github.com/user-attachments/assets/3637f220-e261-495b-8373-e95e86e42277" />

    

## 제어장치

- 제어 신호를 내보내고, 명령어 해석하는 부품
1. 클럭 신호를 받아들임.
    - 클럭? 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
2. 해석해야 할 명령어 받아들임.
3. 플래그 레지스터 속 플래그 값 받아들임
4. 시스템 버스, 그 중에서 제어 버스로 전달된 제어 신호 받아 들임.

<img width="478" alt="image" src="https://github.com/user-attachments/assets/c6d3764c-03a0-4c20-832a-d22323681dde" />

---

# 04-2 레지스터

**우리가 알아야 할 8개 레지스터**

1. 프로그램 카운터
2. 명령어 레지스터
3. 메모리 주소 레지스터
4. 메모리 버퍼 레지스터
5. 플래그 레지스터
6. 범용 레지스터
7. 스택 포인터
8. 베이스 레지스터

### 1. 프로그램 카운터(명령어 포인터)

: 메모리에서 가져올 명령어 주소 저장

### 2. 명령어 레지스터

: 해석할 명령어(방금 메모리에서 읽어들인 명령어) 저장

### 3. 메모리 주소 레지스터

: 메모리 주소 저장

### 4. 메모리 버퍼 레지스터

: 메모리와 주고받을 값(데이터와 명령어)를 저장

### 5. 범용 레지스터

: 다양하고 일반적인 상황에 자유롭게 사용(데이터와 주소 모두 저장 ㄱㄴ)

- 대다수 CPU는 모두 범용  레지스터 가짐

### 플래그 레지스터

- 연산 결과 or CPU 상태에 대한 부가적인 정보를 저장

## 특정 레지스터 이용한 주소 지정방식(1) : 스택 주소 지정 방식

: 스택과 스택 포인터 이용한 주소 지정 방식

- 스택 포인터 ? 스택의 꼭대기 가리키는 레지스터

<img width="302" alt="image" src="https://github.com/user-attachments/assets/4531e73c-28d4-43ae-9e5a-be39ee00ebde" />


## 특정 레지스터 이용한 주소 지정방식(2) : 변위 주소 지정 방식

: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식

- 종류 (오퍼랜드 필드의 주소와 어떤 레지스터를 더하는 지에 따라)
    - 상대 주소 지정 방식 : 오퍼랜드와 **PC값** 더하여 유효 주소를 얻음
    - 베이스 레지스터 주소 지정 방식 : 오퍼랜드와 **베이스 레지스터 값** 더하여 유효 주소 얻음.

<img width="389" alt="image" src="https://github.com/user-attachments/assets/de507baa-0629-44cf-a650-e1fb40d07aeb" />

---

# 04-3 명령어 사이클과 인터럽트

- 명령어 사이클 : 하나의 명령어를 처리하는 흐름
- 인터럽트 : 명령어 처리 흐름이 끊어지는 상황 발생

## 명령어 사이클

명령어 일정 주기 반복 실행되는데 그 주기

- 인출 사이클(fetch cycle) : 명령어를 메모리→CPU로
- 실행 사이클(execution cycle) : CPU로 가져온 명령어 실행

** 모든 명령어가 간단히 이렇게 실행되는 것 아님!
→ 간접 주소 지정 방식같이… CPU로 가져왔다 하더라도 곧바로 실행할 수 없는 경우도 있기 때문!

→ 명령어 실행하기 위해 메모리 접근 한 번더 해야! **간접 사이클**

## 인터럽트

: CPU의 작업을 방해하는 신호

- 종류
    - 동기 인터럽트(예외) : CPU에 의해 발생하는 인터럽트
    - 비동기 인터럽트(하드웨어 인터럽트) : 주로 입출력장치에 의해 발생하는 인터럽트
    → 알림과 같은 인터럽트
    → CPU는 입출력 도중에도 효율적으로 명령어 처리 위해 이를 사용.
        
        <img width="476" alt="image" src="https://github.com/user-attachments/assets/55bc9665-fb53-4ef0-a65e-613fe5ad52cb" />

        
        - 알아야 할 키워드
            - 인터럽트 요청 신호 : CPU에 물어
            - 인터럽트 플래그 : 하드웨어 인터럽트 받아들일지 결정
            - 인터럽트 벡터 : 인터럽트 서비스 루틴 식별 정보(인터럽트 서비스 루틴 시작 주소 포함)
            - 인터럽트 서비스 루틴 : 인터럽트 처리 위한 프로그램
    
    <img width="392" alt="image" src="https://github.com/user-attachments/assets/f7b4837c-65fd-4c51-9c87-97a697b242c6" />

    

cf) 예외 종류

<img width="433" alt="image" src="https://github.com/user-attachments/assets/e7217c7d-700c-4f86-b99d-8194ccd7613d" />


폴트 : 예외 처리 직후 예외 **발생한 명령어부터** 실행 재개

트랩 : 예외 처리 직후 예외 **발생한 다음 명령어부터** 실행 재개

중단 : 강제 중단시킬 수밖에 없는 심각한 오류

소프트웨어 인터럽트 : 시스템 호출이 발생했을 때 나타남
