1. 컴퓨터 구조 시작하기
# 컴퓨터 구조의 큰 그림

- 컴퓨터가 이해하는 정보 ( 0, 1의 조합 )
    - 데이터 : 명령어를 위해 존재하는 재료
    - 명령어 : 데이터 움직이고 컴퓨터 작동시키는 정보
        - 컴퓨터 프로그램 : 명령어들의 모음
- 컴퓨터의 네 가지 핵심 부품
    - CPU( 중앙 처리 장치 )
    - Memory (주 기억 장치)
        - RAM
        - ROM
    - 보조 기억 장치
    - IO device

1. 메모리
- 현재 실행되는 프로그램의 명령어, 데이터 저장하는 부품 ( RAM ) : 휘발성
    - 프로그램 실행 전 메모리에 저장
    - 메모리에 저장된 값의 위치 : 주소로 찾기 가능
1. CPU
- 메모리에 저장된 명령어를 읽고 해석, 실행
- 내부 구성 요소
    - ALU (산술논리연산장치) : 계산 수행
    - 레지스터 : CPU내부 임시 저장 장치
        - 프로그램 실행 위해 필요한 값 임시 저장
        - 각기 다른 이름, 역할 가진 여러 개 존재
    - 제어 장치 : 제어 신호 전송, 명령어 해석
1. 보조기억장치
- 메모리보다 크기 크고 비 휘발성의 저장 장치
1. 입출력장치
- 컴퓨터 외부에 연결 → 컴퓨터 내부와 정보 교환

1. 메인보드(마더보드)와 시스템 버스
- 메인보드
    - 컴퓨터의 핵심 부품 연결
    - 내부 버스를 통해 부품 간 정보 전달
        - 시스템 버스 : 핵심 부품 연결 버스
- 시스템 버스
    - 주소 버스 : 읽고자 하는 메모리 주소
    - 데이터 버스 : 명령어, 데이터
    - 제어 버스 : 제어 신호

2. 데이터
# 0과 1로 숫자를 표현하는 방법

## 정보 단위

- 비트 : 0과 1을 나타내는 가장 적은 정보 단위
    - n bits → 2^n개의 정보 표현
- 바이트 : 8bits
- 워드(Word) : CPU가 한 번에 처리할 수 있는 데이터 크기
    - CPU마다 다름

## 이진법

- 0과 1로 숫자를 표현하는 방법 → 이진수

### 이진수의 음수 표현

- 2의 보수
    - 어떤 수를 그보다 큰 2^n에서 뺀 값
        - 모든 bit를 뒤집고 거기에 1 더한 값
    - ex) 1011의 음수 : 0101
    - 플래그
        - 양수와 음수 구분 (-1011 : 0101 ↔ 십진수 5 : 0101)

## 십육진법

- 0~15 → 0~9 - A~F
- 숫자 앞에 0x붙여 십진수와 구분

### 십육진수 to 이진수

- 십육진수 숫자 하나를 4비트로 표현
    
    ex) 1A2AB → 0001 1010 0010 1011
    

### 이진수 to 십육진수

- 이진수를 4개씩 끊어서 십육진수 1개 숫자로
    
    ex)1101 0101 → D 5
    

# 0과 1로 문자를 표현하는 방법

## 문자 집합과 인코딩

- 문자 집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩 : 문자를 0과 1로 변환하는 과정
- 문자 디코딩 : 0과 1로 이루어진 문자 코드를 문자로 변환하는 과정

## 아스키 코드

- 18개 문자를 1바이트로 정의해둔 표

## EUC-KR(완성형)

- 한글 인코딩
    - 완성형 인코딩 : 완성된 하나의 글자에 고유 코드 부여
    - 조합형 인코딩 : 초성, 중성, 종성을 위한 비트열 할당 → 조합 : 하나의 글자 코드 완성

## 유니코드와 UTF-8

- 유니코드
    - 여러 나라의 문자를 광범위하게 표현할 수 있는 통일된 문자 집합
- UTF-8
    - 유니코드 문자에 부여된 값을 인코딩하는 방식
    - 1~4Byte

3. 명령어
# 소스 코드와 명령어

## 고급 언어와 저급 언어

- 고급 언어
    - 사람이 이해하고 작성하기 쉽게 만들어진 언어
    - 컴파일 언어
    - 인터프리터 언어
- 저급 언어
    - 컴퓨터가 이해하고 실행할 수 있는 언어 ( 명령어의 연속 )
    - 기계어
        - 0, 1로 구성
    - 어셈블리어
        - 기계어를 사람이 읽을 수 있도록 변환

## 컴파일 언어와 인터프리터 언어

### 컴파일 언어

- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되는 고급 언어
    - 컴파일 : 컴파일 언어 → 저급 언어 변환 과정
        - 컴파일러 : 컴파일 수행
    - 목적 코드 : 컴파일 결과 저급 언어
    - 전체 코드 중 오류 있으면 실행 X
    - **전체를 변환**하여 실행

### 인터프리터 언어

- 한 줄 씩 차례로 실행되는 고급 언어
    - 인터프리터 : 소스 코드를 **한 줄 씩** 저급 언어로 변환, 실행
    - 전체 코드 중 오류 있어도 이전 Line까지 실행O

### 목적 파일 vs 실행 파일

- 목적 파일 : 목적 코드로 이루어진 파일
- 실행 파일 : 실행 코드로 이루어진 파일

고급 언어 → 컴파일 → 목적 파일 → 링킹 → 실행 파일

- 링킹 : 목적 파일의 명령어와 실제 수행 기능을 연결 짓는 작업

# 명령어의 구조

명령어 : 기계어나 어셈블리어를 구성

- 연산 코드 + 오퍼랜드

## 연산 코드와 오퍼랜드

- 연산 코드 : 연산자
    - 명령어가 수행할 연산
- 오퍼랜드 : 피연산자
    - 연산에 사용할 데이터 / 연산에 사용할 데이터가 저장된 위치

명령어 구조 : 연산코드 필드 + 오퍼랜드 필드

### 오퍼랜드( 주소 필드 )

- 연산에 사용할 데이터 값
- 메모리 주소, 레지스터 이름 ( 데이터 위치 )
- 오퍼랜드 개수에 따른 명령어 분류
    - 0-주소 명령어
    - 1-주소 명령어
    - 2-주소 명령어
    - 3-주소 명령어

### 연산 코드

- 데이터 전송 : P 94
    - Move
    - Store
    - Load ( Fetch )
    - Push
    - Pop
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

## 주소 지정 방식

- 오퍼랜드 필드에 데이터의 위치가 있을 때 해당 위치를 찾는 방법
- 오퍼랜드 필드에 메모리, 레지스터의 주소를 담는 이유
    - 명령어의 길이는 한정적임
    - ‘주소’ 저장할 경우 명령어에 사용할 수 있는 데이터의 범위 커짐
    - 유효 주소 : 연산의 대상이 되는 데이터가 저장된 위치

- 분류
    - 즉시 주소 지정 방식
        - 오퍼랜드 필드에 데이터를 직접 명시
        - 표현 가능 데이터 범위 작음
        - 속도 빠름
    - 직접 주소 지정 방식
        - 유효 주소를 명시
        - 표현 가능 데이터 범위 커짐
        - 표현 가능 유효 주소 한계 O
    - 간접 주소 지정 방식
        - 유효주소의 주소를 오퍼랜드 필드에 명시
        - 두번의 메모리 접근 필요
        - 속도 느림
    - 레지스터 주소 지정 방식
        - 데이터 저장한 레지스터를 명시
        - 레지스터 : CPU내부에 존재
            - 직접 주소 지정 방식보다 빠름
            - 표현가능 레지스터 개수 제한
    - 레지스터 간접 주소 지정 방식
        - 유효 주소를 레지스터에 저장, 해당 레지스터를 명시
        - 간접 주소 지정 방식보다 빠름

4. CPU의 작동 원리
# ALU와 제어 장치

## ALU

- 입력
    - 피연산자 : 레지스터에서  입력받음
    - 제어 신호(수행할 연산) : 제어 장치에서  입력 받음
- 출력
    - 결괏값 : 레지스터에 저장
    - 플래그 : 플래그 레지스터에 저장
    - 메모리가 아닌 레지스터에 저장하는 이유 : for 속도
- 플래그 : CPU의 실행 위한 참고 정보 - p106
    - 부호 플래그
        - 연산 결과의 부호
    - 제로 플래그
        - 연산 결과가 0? or not
    - 캐리 플래그
        - 연산 결과 올림수 / 빌림수 발생 여부
    - 오버플로우 플래그
        - 오버플로우 발생 여부
    - 인터럽트 플래그
        - 인터럽트 가능 여부
    - 슈퍼바이저 플래그
        - 커널모드 or 사용자 모드

## 제어 장치

- 제어 신호 전송, 명령어 해석 : CPU의 구성요소
- 입력 p.108
    - 클릭 신호
        - 컴퓨터 움직임을 위한 시간 단위
    - 해석 할 명령어
        - 명령어 레지스터에서 받음
        - 해석 후 제어 신호 발생
    - 플래그 ( 추가적인 상태 정보)
        - 플래그 레지스터에서 받음
        - 참고하여 제어 신호 발생
    - 제어 신호 ( CPU내부 + CPU 외부에서 생산된 )
        - 시스템 버스(제어 버스)에서 받음
- 출력
    - 제어 신호
        - to CPU 외부
            
            메모리, 입출력 장치의 값을 읽거나 쓰고 싶을 때
            
            - 제어 버스로 제어 신호 전달
            - to 메모리
            - to 입출력 장치(보조 기억 장치 포함)
        - to CPU 내부
            - to ALU
                - 수행할 연산 지시
            - to 레지스터
                - 레지스터 간 데이터 이동
                - 레지스터에 저장된 명령어 해석

# 레지스터

## 반드시 알아야 할 레지스터

### 프로그램 카운터( 명령어 포인터 )

- 메모리에서 읽어 들일 명령어의 주소 저장

### 명령어 레지스터

- 해석할 명령어 저장( 방금 메모리에서 읽어들인 명령어 )

### 메모리 주소 레지스터

- CPU가 읽을 주소 값을 주소 버스로 보낼 때 사용

### 메모리 버퍼 레지스터

- 메모리와 주고받을 값 ( data or 명령어 ) 저장
- 메모리와 데이터 버스로 주고 받을 값

### 실행 예시 p.114.

- CPU로 실행할 프로그램이 메모리에 저장되어 있음
- CPU : 실행 위해 프로그램 카운터에 실행할 프로그램의 주소(1000번지) 저장됨
- 1000번지 읽기 위해 메모리 주소 레지스터에 1000 저장
- 제어 장치 : 제어 버스로 메모리에 제어 신호 전송( 데이터 읽기 )
    
    메모리 주소 레지스터 : 주소 버스로 메모리에 메모리 주소 전송
    
- 메모리 : 데이터 버스 통해 메모리 버퍼 레지스터로 1000번지에 저장된 데이터 전송
    
    프로그램 카운터  + 1
    
    - for 다음 명령어 읽기
- 메모리 버퍼 레지스터 : 읽어온 값 명령어 레지스터로 전달
- 제어장치 : 명령어 레지스터의 데이터 해석, 제어신호 발생
    - 해당 명령어 처리 끝 → CPU : 다음 명령어 읽기

### 범용 레지스터

- 데이터, 주소 모두 저장 가능 : 범용 사용

### 플래그 레지스터

- 연산 결과 or CPU 상태에 대한 부가 정보 저장

## 특정 레지스터를 이용한 주소 지정 방식(1) : 스택 주소 지정 방식

스택 / 스택 포인터 이용한 주소 지정 방식

### 스택 포인터( 레지스터 )

- 스택의 꼭대기 가리키는 레지스터
- 스택 : 메모리의 스택 영역에 존재

## 특정 레지스터를 이용한 주소 지정 방식(2) : 변위 주소 지정 방식

유효 주소 = 오퍼랜드 필드의 값(변위) + 특정 레지스터 값

- 변위 주소 지정 방식 사용 명령어 구조
    - 연산 코드 + 레지스터 + 오퍼랜드 p121

### 상대 주소 지정 방식

- 유효 주소 = 프로그램 카운터(레지스터) 값 + 오퍼랜드
    - 프로그램 카운터 : 메모리에서 읽어 들일 명령어의 주소 저장

### 베이스 레지스터 주소 지정 방식

- 유효 주소 = 베이스 레지스터 값 + 오퍼랜드
    - 베이스 레지스터 : 기준 주소 저장

# 명령어 사이클과 인터럽트

## 명령어 사이클

프로그램 속 명령어들이 실행되는 주기

- 인출 사이클 : 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클 : CPU로 가져온 명령어 실행하는 단계
- 간접 사이클 : 명령어 실행 위해 추가적인 메모리 접근

## 인터럽트

CPU의 작업을 방해하는 신호

- 동기 인터럽트( 예외 : Exception )
    - CPU에 의해 발생
- 비동기 인터럽트( 하드웨어 인터럽트 )
    - 주로 IO장치에 의해 발생
    - 완료 알림, 입력 알림 등

### 하드웨어 인터럽트

1. CPU가 IO장치에 작업 요청
2. CPU : IO 작업 완료 여부 체크X, 자신의 작업 수행
3. IO장치 : 작업 끝나면 완료 인터럽트 CPU로 전달
4. CPU : 다른 작업 처리하면서 완료 여부 파악 가능

### 하드웨어 인터럽트 처리 순서

p/136

1. IO장치 : CPU에 인터럽트 요청 신호 전달
2. CPU : 실행 사이클 끝나고 명령어 인출 전 인터럽트 여부 확인
3. CPU : 인터럽트 요청 확인 → 인터럽트 플래그 확인, 인터럽트 받을 수 있는지 여부 확인
4.  CPU : 인터럽트 받을 수 있음 →지금까지 작업 스택에 백업
5. CPU : 인터럽트 벡터 참조하여 인터럽트 서비스 루틴 실행
6. CPU : 백업한 작업 복구하여 실행 재개
- 인터럽트 요청 신호
- 인터럽트 플래그 : CPU가 인터럽트 받아들일지 무시할지 결정
    - 해당 플래그 무시 가능한 인터럽트 요청 존재( 막을 수 없는 인터럽트 )
- 인터럽트 서비스 루틴 ( 인터럽트 핸들러 )
    - 인터럽트에 대한 저리
- 인터럽트 벡터 : 인터럽트 서비스 루틴 식별 위한 정보

p.137

명령어 사이클

### 예외( 동기 인터럽트 )

- CPU : 작업 중단, 해당 예외 처리
- 분류
    - 폴트 : 예외 처리 후 예외 발생 명령어부터 실행 재개
    - 트랩 : 예외 처리 후 예외 발생 명령어 다음 명령어부터 실행 재개
    - 중단 : CPU가 실행 중인 프로그램 강제로 중단
    - 소프트웨어 인터럽트 : 시스템 호출

5. CPU 성능 향상 기법
# 빠른 CPU를 위한 설계 기법

## 클럭

- 클럭 신호 : 컴퓨터 부품의 작동 신호
- 클럭 속도 : 1초의 클럭 반복 횟수

## 코어와 멀티 코어

- 코어 : 명령어를 실행하는 부품 p.147
- 멀티 코어 CPU : 다수 코어를 포함하는 CPU
    - 연산 속도가 코어 개수에 정비례하지는 않음
        - 명령어의 분배가 중요

## 스레드와 멀티 스레드

- 스레드 : 실행 흐름의 단위

### 하드웨어적 스레드

- 하나의 코어가 동시에 처리하는 작업 흐름
- 멀티 스레드 CPU(프로세서) : 하나의 코어로 여러 명령어 동시 처리하는 CPU
    - 하이퍼스레딩( by Intel)

### 소프트웨어적 스레드

- 하나의 프로그램에서 독립적으로 실행되는 단위

1코에 1스레드 CPU도 멀티 스레드 프로그램 실행 가능

### 멀티 스레드 프로세서

- 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러개 포함
    - 프로그램 카운터. 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터
- 하드웨어 스레드 : 논리 프로세서
    - 프로그램 입장 : 2코어 4스레드 CPU = 한번에 하나 명령어 처리하는 CPU 4개
        - 작업 흐름이 4개로 동일

## 명령어 병렬 처리 기법

CPU 작업X시간 줄임

## 명령어 파이프라인

- 명령어 처리 과정
    - 클럭단위 분류
        - 인출, 해석, 실행, 저장
        - CPU : 각 단계 동시 실행 가능
        - p.157
- 명령어 파이프라이닝
    - 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 파이프라인 위험 : 파이프라인 시 성능 향상 실패 경우
    - 데이터 위험, 제어 위험, 구조적 위험

### 데이터 위험

- 원인 : 명령어 간 데이터 의존성
    - 특정 명령어 : 이전 명령어 실행 완료해야만 실행 가능 p.159

### 제어 위험

- 원인 : 프로그램 카운터의 갑작스러운 변화( 실행 흐름의 변화 )
    - ‘분기 예측’ 으로 해결

### 구조적 위험 ( 자원 위험 )

- 원인 : 서로 다른 명령어가 동시에 같은 CPU 부품 사용

## 슈퍼스칼라

- 여러개의 명령어 파이프라인을 포함한 구조 p.160

## 비순차적 명령어 처리(OoOE)

- 명령어들을 순차적으로 실행하지 않는 기법
- 서로 데이터 의존성이 없는 명령어들 순서 바꾸기
    - 파이프라인 멈추는 것을 방지

# CISC와 RISC

ISA : CPU의 언어

## 명령어 집합

- ISA : CPU가 이해할 수 있는 명령어들의 모음
    
    HW가 소프트웨어를 어떻게 이해할 지에 대한 약속
    
    - CPU마다 ISA 다름
    - CISC / RISC

## CISC : complex Instruction Set Computer

x86, x86-64 등

- 가변 길이 명령어 활용
    - 적은 수의 명령어로도 프로그램 실행 가능
        - 메모리 절약 가능
        - 실제로는 자주 사용되는 명령어만 사용함..
    - 명령어의 크기, 실행되기까지의 시간 일정X ( 명령어의 규격화 힘듬 )
    - 1명령어 실행에 여러 클럭 주기 필요
    
    → 파이프라인 구현 hard p.171
    

## RISC : Reduced Instruction Set Computer

ARM

- 규격화된 명령어, 1클럭 내외로 실행되는 명령어 지향
- 고정 길이 명령어 활용
    - 파이프라이닝 최적화
    - 메모리 접근 단순화 ( load, store 두개로 제한 )
        - 주소 지정 방식 종류 적음
- 메모리 접근 최소화 → 레지스터 적극 활용
- 같은 프로그램에 대해 CISC보다 많은 명령어 필요